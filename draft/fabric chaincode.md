# 分析方法 

自顶向下 了解chaincode的是如何部署上去的


#  如何写一个智能合约 

https://github.com/IBM-Blockchain/learn-chaincode

#  chaincode 如何执行 

如何安装


# 打桩 

具体实现
细节需要分析  



# 智能合约编写规范 

```
type DunChaincode struct {
}

func (t *DunChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {
	return t.init(stub)
}

func (t *DunChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {
	function, args := stub.GetFunctionAndParameters()
	if function == "bid" { //投标
		return t.bid(stub, args)
	} else if function == "queryBid" { //查询投标信息
		return t.queryBid(stub, args)
	} else if function == "queryBidsByTender" { //根据招标uuid查询投标列表
		return t.queryBidsByTender(stub, args)
	}

	return shim.Error("Invalid invoke function name.")
}
```


# ChaincodeID

在程序环境下描述chaincode 

很多chaincodeID 如何区分 
如何描述

```
type ChaincodeID struct {
	// deploy transaction will use the path
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// all other requests will use the name (really a hashcode) generated by
	// the deploy transaction
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// user friendly version name for the chaincode
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}
```

# 业务层 chaincode是如何执行的呢？


# chaincode 是怎么支持plugable?




# chaincode 是如何安装的 

安装命令 

```
peer chaincode install -n myc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02
```
这个目录的要求是什么？


# chaincodemsg 消息类型 

```
message ChaincodeMessage {

    enum Type {
        UNDEFINED = 0;
        REGISTER = 1;
        REGISTERED = 2;
        INIT = 3;
        READY = 4;
        TRANSACTION = 5;
        COMPLETED = 6;
        ERROR = 7;
        GET_STATE = 8;
        PUT_STATE = 9;
        DEL_STATE = 10;
        INVOKE_CHAINCODE = 11;
        RESPONSE = 13;
        GET_STATE_BY_RANGE = 14;
        GET_QUERY_RESULT = 15;
        QUERY_STATE_NEXT = 16;
        QUERY_STATE_CLOSE = 17;
        KEEPALIVE = 18;
        GET_HISTORY_FOR_KEY = 19;
    }

    Type type = 1;
    google.protobuf.Timestamp timestamp = 2;
    bytes payload = 3;
    string txid = 4;

    SignedProposal proposal = 5;

    //event emmited by chaincode. Used only with Init or Invoke.
    // This event is then stored (currently)
    //with Block.NonHashData.TransactionResult
    ChaincodeEvent chaincode_event = 6;
}
```
通过proto来理解相互通信问题  

# 通过chaincode 学习如何将一个业务的概念落地到代码 

静态描述：

数据本身

外部关系  例如同外部的交互

数据结构有哪些 


动态执行：
初始化
状态改变

接口代表对外连接  

协议描述 


# peer节点是如何知道chaincode？


# 多个chaincode 是如何区分的

通过chaincodeid来解决的 

# chaincode结构体 


```
// ChaincodeSupport responsible for providing interfacing with chaincodes from the Peer.
type ChaincodeSupport struct {
	runningChaincodes *runningChaincodes
	peerAddress       string
	ccStartupTimeout  time.Duration
	peerNetworkID     string
	peerID            string
	peerTLSCertFile   string
	peerTLSKeyFile    string
	peerTLSSvrHostOrd string
	keepalive         time.Duration
	chaincodeLogLevel string
	shimLogLevel      string
	logFormat         string
	executetimeout    time.Duration
	userRunsCC        bool
	peerTLS           bool
}
```

# chaincode 命令行 



